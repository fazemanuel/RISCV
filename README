README.md 
xv6-riscv — Explicación 

Aviso de origen
Este repositorio contiene el código original de xv6-riscv (MIT) con comentarios y documentación añadidos en español para explicar su funcionamiento interno. El código base pertenece al proyecto xv6; revisa la licencia incluida por el MIT.

Nota sobre esta versión
Las partes que explican el planificador de CPU y la gestión de memoria están documentadas en español dentro del código, añadiendo comentarios aclaratorios directamente sobre las funciones relevantes (sin modificar la lógica del kernel).

Propósito de este README

Presenta una explicación general del funcionamiento del planificador de CPU y la gestión de memoria, e indica precisamente en qué archivos del proyecto se encuentran las implementaciones. Esto sirve de mapa para navegar el código.

1. Planificador de CPU (scheduler)
Funcionamiento general

El scheduler recorre procesos en estado RUNNABLE y les da tiempo de CPU mediante conmutación de contexto. Es un planificador simple tipo round-robin adecuado para un kernel educativo.

Archivos donde encontrar el scheduler

Para estudiar y comprender el planificador revisa los siguientes archivos:

kernel/proc.c
Aquí está:

scheduler() — bucle principal del planificador por CPU.

yield() — permite que un proceso ceda la CPU.

sleep() y wakeup() — mecanismos de espera y notificación.

fork(), exit(), wait() — creación/destrucción de procesos y transición de estados.

allocproc() — creación de estructuras struct proc.

kernel/swtch.S
Implementa el context switch a nivel de ensamblador: guarda y restaura registros del contexto de un proceso.

kernel/spinlock.c
Código relacionado con la sincronización usada por el scheduler para evitar condiciones de carrera.

kernel/trap.c
Las interrupciones de timer vuelven eventualmente al scheduler marcando necesidad de ceder CPU.

Breve idea de funcionamiento

scheduler() recorre el arreglo global de procesos, elige el primero RUNNABLE, lo marca como RUNNING, realiza un cambio de contexto a su pila del kernel y lo deja ejecutar hasta que regrese al scheduler (por yield, sleep, exit, interrupción, etc.).

Las secciones relevantes dentro de proc.c ya están comentadas en español en esta versión del repositorio.

2. Gestión de memoria

La memoria en xv6 se divide conceptualmente en dos subsistemas:
a) asignación de páginas físicas y
b) gestión del espacio de direcciones de usuario mediante tablas de páginas.

Archivos donde encontrar la gestión de memoria

kernel/kalloc.c
Implementación del asignador físico de páginas:

kalloc() — entrega páginas físicas libres.

kfree() — devuelve páginas a la lista libre.

Lista enlazada de páginas disponibles.

kernel/vm.c
(Nombre puede variar según versión: a veces vm.c, vm.rs, etc.)
Contiene casi toda la lógica de memoria virtual:

walk() — localizar/crear PTEs en la tabla de páginas.

mappages() — mapear rangos virtuales→físicos.

uvmalloc, uvmfree, uvmdealloc — crecimiento y destrucción del espacio de direcciones.

copyout y copyin — transferencias seguras entre kernel y usuario.

kernel/exec.c

Carga de ejecutables ELF.

Construcción de una nueva tabla de páginas para el proceso.

Reserva y mapeo de memoria inicial del programa.

kernel/proc.c
fork() utiliza funciones de vm.c para copiar el espacio de direcciones del padre al hijo (en xv6 clásico no hay copy-on-write).
También aquí se libera memoria de procesos terminados.

Cómo funciona cada parte

La explicación se mantiene igual a la versión previa, pero se aclara dónde está implementado:

El asignador físico (kalloc.c) maneja páginas individuales mediante free-lists.
Las tablas de páginas (vm.c) traducen direcciones virtuales→físicas usando el esquema de paginación Sv39 de RISC-V.
exec.c construye el espacio de direcciones inicial.
proc.c coordina asignación y liberación durante creación/terminación de procesos.

Todas estas secciones contienen comentarios en español en esta versión del repositorio, explicando las funciones clave.

3. Resumen práctico — dónde mirar primero

Para estudiar el scheduler:
revisa proc.c, sección scheduler(), más yield, sleep, wakeup.

Para estudiar memoria:
primero kalloc.c (páginas físicas),
luego vm.c (paginación y mapeo),
y finalmente exec.c y fork en proc.c.

Esta versión del repositorio añade comentarios en español directamente sobre esas funciones.

4. Licencia y atribución

Este README y los comentarios explicativos están en español, pero todo el código base pertenece al proyecto xv6-riscv del MIT, con su licencia original incluida sin modificaciones.